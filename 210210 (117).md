### 1.restful을 적용하여 게시판을 구현을 완성하시오.(URL 설계 포함)

### [ 구현 코드 ]

#### 1. 기본 spring MVC 게시판 만들기 기본 설정까지 완료

- root-context.xml 파일 복사할 때 컨택스트명 바꾸는 것 잊지 말 것!



#### 2. 테스트 부분

- 라이브러리 설치 안되어 있으면 프로젝트 - properties - java Build Path - library - add - JUnit 추가
- 처음 기본 설정 끝낸 후 connection 테스트 먼저 진행하고, 컨트롤러 이후 부분은 로직이 만들어지는대로 테스트 진행

**< 커넥션풀 테스트 >**

**[ src.test.java ] - com.bit.brd.connection - ConnectionTest.java**

```
package com.bit.brd.connection;

import static org.junit.Assert.*;

import javax.sql.DataSource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import lombok.extern.log4j.Log4j;

@RunWith(SpringRunner.class)
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
@Log4j
public class ConnectionTest {

	@Autowired
	DataSource dataSource;
	
	@Test
	public void testDataSource() {
		assertNotNull(dataSource);
	}
}
```

**< service 테스트 >**

**< mapper 테스트 >**

**< controller 테스트 >**





#### 3. 게시판 부분

**[ com.bit.brd.vo ] - RestfulBoardVO.java**

- getter/setter, 생성자를 롬복으로 처리해봤으나 에러나서 다시 수동으로 생성해줌.

```
package com.bit.brd.vo;

import java.sql.Timestamp;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.log4j.Log4j;

@Log4j
public class RestfulBoardVO {
	private int iId;
	private String iName;
	private String iTitle;
	private String iContent;
	private Timestamp iDate;
	private int iHit;
	private int iGroup;
	private int iStep;
	private int iIndent;
	
	public RestfulBoardVO() {
		
	}

	public RestfulBoardVO(int iId, String iName, String iTitle, String iContent, Timestamp iDate, int iHit, int iGroup, int iStep, int iIndent) {
		
		this.iId = iId;
		this.iName = iName;
		this.iTitle = iTitle;
		this.iContent = iContent;
		this.iDate = iDate;
		this.iHit = iHit;
		this.iGroup = iGroup;
		this.iStep = iStep;
		this.iIndent = iIndent;
	}

	public int getiId() {
		return iId;
	}

	public void setiId(int iId) {
		this.iId = iId;
	}

	public String getiName() {
		return iName;
	}

	public void setiName(String iName) {
		this.iName = iName;
	}

	public String getiTitle() {
		return iTitle;
	}

	public void setiTitle(String iTitle) {
		this.iTitle = iTitle;
	}

	public String getiContent() {
		return iContent;
	}

	public void setiContent(String iContent) {
		this.iContent = iContent;
	}

	public Timestamp getiDate() {
		return iDate;
	}

	public void setiDate(Timestamp iDate) {
		this.iDate = iDate;
	}

	public int getiHit() {
		return iHit;
	}

	public void setiHit(int iHit) {
		this.iHit = iHit;
	}

	public int getiGroup() {
		return iGroup;
	}

	public void setiGroup(int iGroup) {
		this.iGroup = iGroup;
	}

	public int getiStep() {
		return iStep;
	}

	public void setiStep(int iStep) {
		this.iStep = iStep;
	}

	public int getiIndent() {
		return iIndent;
	}

	public void setiIndent(int iIndent) {
		this.iIndent = iIndent;
	}	
	
}

```

**[ com.bit.brd.controller ] **

- 컨트롤러 클래스 어노테이션
  - @Controller (X) → @RestController (O)
    - @Controller 대신 위 어노테이션으로 변경
    - @Controller과 차이 : 메소드가 종료되면 화면 전환이 되는가, 되지 않는가 차이
  - @RequestMapping
    - /컨텍스트명/restful/... 로 들어오는 모든 접근은 이 클래스에서 받아 처리한다는 의미
    - @RequestMapping는 스프링 4.0부터 지원
- **list 메소드** 어노테이션
  - @GetMapping("/board")  :  최종 URI는 '/컨텍스트명/restful/board'
- 메소드 만들기
  - ★ 받아온 데이터는 **ModelAndView**에 담아야 함.
    - **ModelAndView** 사용법 : ModelAndView를 메소드 데이터타입으로 줌 + ModelAndView 객체 생성(@AllArgsConstrutor가 있으면 생략 가능) + setViewName으로 view 이름 지정 + addObject으로 view로 보낼 데이터 넣기 + 리턴값으로 ModelAndView 객체
    - ModelAndView를 매개 변수로 사용한다면 해당 메소드의 리턴타입도 **ModelAndView**
  - 페이징을 위해 Criteria 객체 가져와서 getList 메소드에 실어 xml에서 연산해야 함. + getTotal도 같이.
- setViewName으로 지정한 list view 만들기

**< list 가져오기 + 페이징 처리 - RestfulBoardController.java>**

```
package com.bit.brd.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.ModelAndView;

import com.bit.brd.page.Criteria;
import com.bit.brd.page.PageVO;
import com.bit.brd.service.RestfulBoardService;
import com.bit.brd.vo.RestfulBoardVO;

import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Log4j
@AllArgsConstructor
@RestController
@RequestMapping("/restful/*")
public class RestfulBoardController {

	private RestfulBoardService boardService;
	
	@GetMapping("/board")
	public ModelAndView list(ModelAndView mav, Criteria cri) {
		log.info("list");
		mav.setViewName("list");
		mav.addObject("list", boardService.getList(cri));
		
		int total = boardService.getTotal(cri);
		log.info("total" + total);
		mav.addObject("pageMaker", new PageVO(cri, total));
		
		return mav;
	}
	
}

```

**< list 가져오기 + 페이징 처리 - RestfulBoardService.java >**

```
package com.bit.brd.service;

import java.util.List;

import com.bit.brd.page.Criteria;
import com.bit.brd.vo.RestfulBoardVO;

public interface RestfulBoardService {

	public List<RestfulBoardVO> getList(Criteria cri);

	public int getTotal(Criteria cri);

}
```

**< list 가져오기 + 페이징 처리 - RestfulBoardServiceImpl.java >**

```
package com.bit.brd.service;

import java.util.List;

import org.springframework.stereotype.Service;

import com.bit.brd.mapper.RestfulBoardMapper;
import com.bit.brd.page.Criteria;
import com.bit.brd.vo.RestfulBoardVO;

import jdk.internal.org.jline.utils.Log;
import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Log4j
@Service
@AllArgsConstructor
public class RestfulBoardServiceImpl implements RestfulBoardService {
	public RestfulBoardMapper boardMapper;
	
	@Override
	public List<RestfulBoardVO> getList(Criteria cri) {
		log.info("getList");
		return boardMapper.getList(cri);
	}

	@Override
	public int getTotal(Criteria cri) {
		log.info("get total count");
		return boardMapper.getTotal(cri);
	}

}
```

**< list 가져오기 + 페이징 처리 - RestfulBoardMapper.java >**

```
package com.bit.brd.mapper;

import java.util.List;

import com.bit.brd.page.Criteria;
import com.bit.brd.vo.RestfulBoardVO;

public interface RestfulBoardMapper {

	public List<RestfulBoardVO> getList(Criteria cri);

	public int getTotal(Criteria cri);

}
```

**< list 가져오기 + 페이징 처리 - RestfulBoardMapper.xml >**

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.bit.brd.mapper.RestfulBoardMapper">	
	<select id="getList" resultType="com.bit.brd.vo.RestfulBoardVO">
		<![CDATA[
			select * from (select rownum as rnum, A. * from (select * from information order by iGroup desc, iStep asc) A where rownum <= #{nowPage} * #{amount} ) where rnum > (#{nowPage} - 1) * #{amount}
		]]>
	</select>
	
	<select id="getTotal" resultType="int">
		<![CDATA[
			select count(*) from information
		]]>
	</select>

</mapper>
```

- **content_view 메소드** 어노테이션
  - @GetMapping("/board/{iId}")
- 메소드 만들기
  - DB에서 jsp로 데이터를 가져와야 하므로 ModelAndView 객체 이용
  - URI의 {iId} 처리 방법
    - ① pathVariable 사용 : 파라미터에 @PathVariable("iId") String iId 주는 것.
    - ② command 사용 : 파라미터에 BoardVO boardVO 매개변수로 주기
- setViewName으로 지정한 content_view 만들기

**< content_view 가져오기 - RestfulBoardController.java >**

```
	@GetMapping("/board/{iId}")
	public ModelAndView contentView(ModelAndView mav, RestfulBoardVO boardVO) {
		log.info("content_view");
		mav.setViewName("content_view");
		mav.addObject("content_view", boardService.contentView(boardVO.getiId()));
	
		return mav;
	}
```

**< content_view 가져오기 - RestfulBoardService.java >**

```
	public RestfulBoardVO contentView(int getiId);
```

**< content_view 가져오기 - RestfulBoardServiceImpl.java >**

```
	@Transactional
	@Override
	public RestfulBoardVO contentView(int getiId) {
		boardMapper.addHit(getiId);
		return boardMapper.contentView(getiId);
	}
```

**< content_view 가져오기 - RestfulBoardMapper.java >**

```
	public RestfulBoardVO contentView(int getiId);
	
	public void addHit(int getiId);
```

**< content_view 가져오기 - RestfulBoardMapper.xml>**

```
	<select id="contentView" resultType="com.bit.brd.vo.RestfulBoardVO">
		<![CDATA[
			select * from information where iId = #{getIid}
		]]>
	</select>
	
	<update id="addHit">
		<![CDATA[
			update information set iHit = iHit + 1 where iId = #{iId}
		]]>
	</update>	
```

- **modify 메소드** 어노테이션
  - @PutMapping("/board/{iId}")
- 메소드 만들기
  - DB에서 데이터를 가져오지 않고 변경만 하므로 ResponseEntity< String > 객체를 이용하고, 리턴 값도 ResponseEntity< String > 를 담은 변수로 함
    - ResponseEntity< String >는 ModelAndView와 다르게 매개변수로 주지 않고, 따로 변수를 만들어 null로 초기화 함.
  - try catch로 묶어주도록 함.
  - jsp에서 form 태그로 비동기 통신을 이용할 때는 보안 이슈 때문에 일반적인 방법으로 데이터를 받을 수 없음. 따라서 **@RequestBody** 어노테이션을 이용해 매개변수를 받도록 함.
  - DB만 변동 사항이 있는 메소드는 Servic, Mapper에서 리턴타입이 "void"

**< modify - RestfulBoardController.java >**

```
	@PutMapping("/board/{iId}")
	public ResponseEntity<String> modify(@RequestBody RestfulBoardVO boardVO) {
		ResponseEntity<String> entity = null;
		
		log.info("modify");
		
		try {
			boardService.modify(boardVO);
			entity = new ResponseEntity<String>("SUCCESS", HttpStatus.OK);
		}catch(Exception e){
			e.printStackTrace();
			entity = new ResponseEntity<String>(e.getMessage(), HttpStatus.BAD_REQUEST);
		}
	
		return entity;
	}
```

**< modify - RestfulBoardService.java >**

```
	public void modify(RestfulBoardVO boardVO);
```

**< modify - RestfulBoardServiceImpl.java >**

```
	@Override
	public void modify(RestfulBoardVO boardVO) {
		boardMapper.modify(boardVO);
	}
```

**< modify - RestfulBoardMapper.java >**

```
	public void modify(RestfulBoardVO boardVO);
```

**< modify - RestfulBoardMapper.xml >**

```
	<update id="modify">
		<![CDATA[
			update information set iName=#{iName}, iTitle=#{iTitle}, iContent=#{iContent} where iId = #{iId}
		]]>
	</update>
```

- **delete 메소드** 어노테이션
  - @DeleteMapping("/board/{iId}")
- 메소드 만들기
  - DB에서 데이터를 가져오지 않고 변경만 하므로 ResponseEntity< String > 객체를 이용하고, 리턴 값도 ResponseEntity< String > 를 담은 변수로 함
    - ResponseEntity< String >는 ModelAndView와 다르게 매개변수로 주지 않고, 따로 변수를 만들어 null로 초기화 함.
  - try catch로 묶어주도록 함.
  - list.jsp에서 받아온 iId는 꼭 board.getiId()가 아니어도 boardVO로 받을 수 있음.
  - DB만 변동 사항이 있는 메소드는 Servic, Mapper에서 리턴타입이 "void"

**< delete - RestfulBoardController.java >**

```
	@DeleteMapping("/board/{iId}")
	public ResponseEntity<String> delete(RestfulBoardVO boardVO){
		ResponseEntity<String> entity = null;
		
		log.info("delete");
		
		try {
			boardService.delete(boardVO);
			entity = new ResponseEntity<String>("SUCCESS", HttpStatus.OK);
		}catch(Exception e){
			e.printStackTrace();
			entity = new ResponseEntity<String>(e.getMessage(), HttpStatus.BAD_REQUEST);
		}
	
		return entity;
	}
```

**< delete - RestfulBoardService.java >**

```
	public void delete(RestfulBoardVO boardVO);
```

**< delete - RestfulBoardServiceImpl.java >**

```
	@Override
	public void delete(RestfulBoardVO boardVO) {
		boardMapper.delete(boardVO);
	}
```

**< delete - RestfulBoardMapper.java >**

```
	public void delete(RestfulBoardVO boardVO);
```

**< delete - RestfulBoardMapper.xml  >**

```
	<delete id="delete">
		<![CDATA[
			delete from information where iId = #{iId}
		]]>
	</delete>
```

- **reply_view 메소드** 어노테이션
  - @GetMapping("/board/reply_view/{iId}")
- 메소드 만들기
  - jsp로 이동해야 하므로 ModelAndView 사용

**< reply_view - RestfulBoardController.java >**

```
	@GetMapping("/board/reply_view/{iId}")
	public ModelAndView replyView(ModelAndView mav, RestfulBoardVO boardVO) {
		log.info("reply_view");
		mav.setViewName("reply_view");
		mav.addObject("reply_view", boardService.replyView(boardVO));
		
		return mav;
	}
```

**< reply_view - RestfulBoardService.java >**

```
	public RestfulBoardVO replyView(RestfulBoardVO boardVO);
```

**< reply_view - RestfulBoardServiceImpl.java >**

```
	@Override
	public RestfulBoardVO replyView(RestfulBoardVO boardVO) {
		return boardMapper.replyView(boardVO);
	}
```

**< reply_view - RestfulBoardMapper.java >**

```
	public RestfulBoardVO replyView(RestfulBoardVO boardVO);
```

**< reply_view - RestfulBoardMapper.xml>**

```
	<select id="replyView" resultType="com.bit.brd.vo.RestfulBoardVO">
		<![CDATA[
			select * from information where iId = #{iId}
		]]>
	</select>
```

- **reply 메소드** 어노테이션
  - @PostMapping("/board/{iId}")
    - iId가 xml에서 직접적으로 필요없다고 생각해 생략해봤으나, 작동하지 않았음. 있어야 함.
- 메소드 만들기
  - reply_view.jsp에서 ajax로 post로 넘긴 걸 받으려면 @RequestBody 있어야 함.

**< reply_view - RestfulBoardController.java >**

```
	@PostMapping("/board/{iId}")
	public ResponseEntity<String> reply(@RequestBody RestfulBoardVO boardVO){
		ResponseEntity<String> entity = null;
		
		log.info("reply");
		
		try {
			boardService.reply(boardVO);
			entity = new ResponseEntity<String>("SUCCESS", HttpStatus.OK);
		}catch(Exception e){
			e.printStackTrace();
			entity = new ResponseEntity<String>(e.getMessage(), HttpStatus.BAD_REQUEST);
		}
		
		return entity;
	}
```

**< reply_view - RestfulBoardService.java >**

```
	public void reply(RestfulBoardVO boardVO);
```

**< reply_view - RestfulBoardServiceImpl.java >**

```
	@Transactional
	@Override
	public void reply(RestfulBoardVO boardVO) {
		boardMapper.replyShape(boardVO);
		boardMapper.reply(boardVO);
	}
```

**< reply_view - RestfulBoardMapper.java >**

```
	public void reply(RestfulBoardVO boardVO);

	public void replyShape(RestfulBoardVO boardVO);
```

**< reply_view - RestfulBoardMapper.xml>**

```
	<insert id="reply">
		<![CDATA[
			insert into information (iId, iName, iTitle, iContent, iGroup, iStep, iIndent) values (information_seq.nextval, #{iName}, #{iTitle}, #{iContent}, #{iGroup}, #{iStep}+1, #{iIndent}+1 )
		]]>
	</insert>
	
	<update id="replyShape">
		<![CDATA[
			update information set iStep = iStep + 1 where iGroup = #{iGroup} and iStep > #{iStep}
		]]>
	</update>
```



#### 4. 페이징 부분 ( spring_게시판 만들기 _ 소스코드.md ) 

- 서버에서 실행하고 f12 소스보기 하면 해당 링크에 어떻게 걸려 있는지 알 수 있으니 참고하자!

- cf. 면접에서 페이징 처리를 어떻게 하는지 묻는다면?

  → 크게 UI 처리 부분과 DB 쿼리 처리를 위한 부분으로 나뉜다.

  → UI 처리를 위해서 변수 9개에 함수로 처리한다. + 어떤 변수가 있는지 대략적으로 설명

  →  DB 쿼리 처리를 위해서는 오라클 11g 이하에서는 rownum으로 처리하고, mySQL에서는 limit으로 

  ​	처리한다.

  

- 구조

  - UI 처리를 위한 설계
  - DB 쿼리 처리
    - DBMS(mySQL, 오라클 11g 이하, 오라클 12 이상 등)에 따라 처리 방법이 조금씩 다름.
    - mySQL는 limit으로 처리하는데 비교적 간단한 편.
    - 오라클 12 이상에서는 limit을 지원하지만, 11g 이하에서는 지원하지 않음. 실무에서는 아직 11g 이하를 많이 사용함.



**UI 처리 부분 : [ com.bit.brd.page ] - Criteria.java**

- 먼저, 새로운 패키지에 (ex. edu.bit.ex.page) 클래스를 만들고 현재 페이지 번호 / 한 페이지에 보여줄 데이터를 담을 변수를 만듦

  1. 현재 페이지 번호 + 한 페이지에 몇 개를 보여줄 지를 담는 변수 만들기

  2. 게터, 세터, toString을 롬복으로 만들어줌 (잘 안되면 수동 생성하자)

  3. 생성자 만들기 + 디폴트 생성자에서 this로 호출한 후 값 초기화하기

```
package com.bit.brd.page;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@ToString
@Getter
@Setter
public class Criteria {
	private int nowPage;
	private int amount;
	
	public Criteria() {
		this(1, 10);
	}

	public Criteria(int nowPage, int amount) {
		this.nowPage = nowPage;
		this.amount = amount;
	}
	
}
```

**UI 처리 부분 : [ com.bit.brd.page ] - PageVO.java**

- 다음으로 페이징을 하기 위해 필요한 정보를 넣고 연산하는 클래스를 만든 후, 생성자에 로직을 구현.

  4.  페이지 처리에 필요한 정보를 넣기 위한 클래스 만들기 

  5.  변수 만들기 + Criteria 객체 호출 + getter/toString 생성

  6.  생성자 만들기

  7.  Getter, toString 롬복으로 만들기

```
package com.bit.brd.page;

import org.springframework.web.util.UriComponents;
import org.springframework.web.util.UriComponentsBuilder;

import lombok.Getter;
import lombok.ToString;

@ToString
@Getter
public class PageVO {
	private int startPage, endPage, total;
	private Criteria cri;
	private boolean prev, next;
	
	public PageVO(Criteria cri, int total) {
		this.total = total;
		this.cri = cri;
		
		this.endPage = (int)(Math.ceil(cri.getNowPage() / 10.0)) * 10;
		this.startPage = this.endPage - 9;
		
		int realEnd = (int)(Math.ceil((total * 1.0) / cri.getAmount()));
		if(realEnd <= endPage) {
			this.endPage = realEnd;
		}
		
		this.prev = this.startPage > 1;
		this.next = realEnd > this.endPage;
	}
	
	public String makeQuery(int page) {
		UriComponents uriComponentsBuilder = UriComponentsBuilder.newInstance().queryParam("nowPage", page).queryParam("amount", cri.getAmount()).build();

		return uriComponentsBuilder.toString();
	}
	
}
```

**UI 처리 부분 : [ com.bit.brd.controller] - RestfulBoardController.java**

```
package com.bit.brd.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.ModelAndView;

import com.bit.brd.page.Criteria;
import com.bit.brd.page.PageVO;
import com.bit.brd.service.RestfulBoardService;

import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Log4j
@AllArgsConstructor
@RestController
@RequestMapping("/restful/*")
public class RestfulBoardController {
	private RestfulBoardService boardService;
	
	@GetMapping("/board")
	public ModelAndView list(ModelAndView mav, Criteria cri) {
		log.info("list");
		mav.setViewName("list");
		mav.addObject("list", boardService.getList(cri));
		
		int total = boardService.getTotal(cri);
		log.info("total" + total);
		mav.addObject("pageMaker", new PageVO(cri, total));
		
		return mav;
	}
}
```

**UI 처리 부분 : [ com.bit.brd.service] - RestfulBoardService.java**

```
package com.bit.brd.service;

import java.util.List;

import com.bit.brd.page.Criteria;
import com.bit.brd.vo.RestfulBoardVO;

public interface RestfulBoardService {

	public List<RestfulBoardVO> getList(Criteria cri);

	public int getTotal(Criteria cri);

}
```

**UI 처리 부분 : [ com.bit.brd.service] - RestfulBoardServiceImpl.java**

```
package com.bit.brd.service;

import java.util.List;

import org.springframework.stereotype.Service;

import com.bit.brd.mapper.RestfulBoardMapper;
import com.bit.brd.page.Criteria;
import com.bit.brd.vo.RestfulBoardVO;

import jdk.internal.org.jline.utils.Log;
import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Log4j
@Service
@AllArgsConstructor
public class RestfulBoardServiceImpl implements RestfulBoardService {
	public RestfulBoardMapper boardMapper;
	
	@Override
	public List<RestfulBoardVO> getList(Criteria cri) {
		log.info("getList");
		return boardMapper.getList(cri);
	}

	@Override
	public int getTotal(Criteria cri) {
		log.info("get total count");
		return boardMapper.getTotal(cri);
	}

}
```

**UI 처리 부분 : [ com.bit.brd.mapper] - RestfulBoardMapper.java**

```
package com.bit.brd.mapper;

import java.util.List;

import com.bit.brd.page.Criteria;
import com.bit.brd.vo.RestfulBoardVO;

public interface RestfulBoardMapper {

	public List<RestfulBoardVO> getList(Criteria cri);

	public int getTotal(Criteria cri);

}
```

**DB 처리 부분 : [ src/main/resources] - [ com.bit.brd.mapper] - RestfulBoardMapper.xml**

- getTotal의 resurtType을 int로 하지 않으면 attempted to return null from a method with a primitive return type (int) 에러 발생

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.bit.brd.mapper.RestfulBoardMapper">	
	<select id="getList" resultType="com.bit.brd.vo.RestfulBoardVO">
		<![CDATA[
			select * from (select rownum as rnum, A. * from (select * from information order by iGroup desc, iStep asc) A where rownum <= #{nowPage} * #{amount} ) where rnum > (#{nowPage} - 1) * #{amount}
		]]>
	</select>
	
	<select id="getTotal" resultType="int">
		<![CDATA[
			select count(*) from information
		]]>
	</select>
</mapper>
```

**브라우저 출력 : [ views ] - list.jsp**  →   5번 jsp 참고







#### 5. jsp 

- Ajax로 비동기 통신 이용하기
- 주의
  - jQuery 이용을 위해서는 라이브러리 필요!!
  - JSTL 사용을 위해서는 태그 라이블러리 필요!!

#### **[ views ] - list.jsp**

- 행 반복문 돌릴 때, items는 반드시 ${}로 가져오자..!

- 페이징 처리할 때 prev, 페이지 숫자, next 링크 부분은 **컨택스트명을 제외한 list 메소드의 맵핑 부분**만 적어줌

- 주석에 ${} = EL 태그를 넣어도 에러날 수 있으니 주의

- list.jsp에서 제목을 클릭했을 때 content_view.jsp로 넘어가는 링크는 단순히 페이지만 넘어가는 기능이므로 ajax를 만드는 것이 아님!!! 링크에 명시된 대로 get 방식의 "board/{iId}" 맵핑을 가진 메소드를 수행하게 됨.

  list.jsp에서의 ajax는 delete 밖에 없음.

```
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>  
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<script type="text/javascript">
	$(document).ready(function(){
		$(".delete").click(function(event){				// "" 잊지 말 것 !!!
			event.preventDefault();
			console.log("delete click");
			
			var tr = $(this).parent().parent();
			
			$.ajax({
				type : "DELETE",
				url : $(this).attr("href"),
				cache : false,
				success : function(result){
					console.log("result : " + result );
					if(result == "SUCCESS"){
						$(tr).remove();
					}
				},
				error : function(e){
					alert("오류가 발생했습니다.");
					console.log(e);
				}
			}); // ajax end
		}); // event end
	}); // ready end
</script>

</head>
<body>
	<table width="600" cellpadding="0" cellspacing="0" border="1">
		<tr>
			<td>글번호</td>
			<td>이름</td>
			<td>제목</td>
			<td>날짜</td>
			<td>조회수</td>
			<td>삭제</td>						
		</tr>
		
		<!-- items는 $로 가져오자....! -->
		<c:forEach items="${list }" var="list">
		<tr>
			<td>${list.iId }</td>
			<td>${list.iName }</td>
			
			<td>
				<c:forEach begin="1" end="${list.iIndent }">[re:]</c:forEach>
				<a href="${pageContext.request.contextPath }/restful/board/${list.iId}">${list.iTitle }</a>			
			</td>
			
			<td>${list.iDate }</td>
			<td>${list.iHit }</td>
			<td><a class="delete" href="${pageContext.request.contextPath }/restful/board/${list.iId}">삭제</a></td>						
		</tr>	
		</c:forEach>
		
		<tr>
			<!-- 링크 미완성 -->
			<td colspan="6"><a href="${pageContext.request.contextPath }/restful/board/">글 작성</a></td>
		</tr>	
	</table>
	
		  <c:if test="${pageMaker.prev}">
	         <a href="board${pageMaker.makeQuery(pageMaker.startPage - 1) }"><<</a>
	      </c:if>
			
		  <!-- 1, 2, 3, ... 링크 건 페이지가 출력되는 부분 -->
	      <c:forEach begin="${pageMaker.startPage }" end="${pageMaker.endPage }" var="idx">
	         <a href="board${pageMaker.makeQuery(idx)}">${idx}</a>
	      </c:forEach>
	      
	      <!-- next 출력되는 부분 -->
	      <c:if test="${pageMaker.next && pageMaker.endPage > 0}">
	         <a href="board${pageMaker.makeQuery(pageMaker.endPage +1) }"> >> </a>
	      </c:if> <br> 
</body>
</html>
```

#### **[ views ] - content_view.jsp**

-  form 태그를 사용해 데이터를 보낼 때는 PUT 맵핑은 보안 이슈 때문에 form 태그의 메소드로는 지원이 안됨. 따라서 다른 방법을 사용해야 함.
  - data : JSON.stringify(form)
    - 이때 form은 자바스크립트의 객체 형식으로 가져갈 내용들을 변수에 담아 넣어줘야 함.
    - 변수에 담을 때 input 태그의 value 값을 가져오는 메소드를 사용해야 하기 때문에 input 태그의 이름은 name이 아닌 id를 사용하도록 하자.
  - contentType : 'application/json; charset=utf-8'
- 비동기 통신이 성공했을 때는 DB 수정이 끝나고 다시 목록을 보여줘야 하므로, $(location).attr(리스트 맵핑)을 명시하도록 함.
- 주의 사항
  - html 태그에 id값을 주고 jQuery로 불러올 때는 $( **" "** ) 꼭 **" "** 안에 적어줘야 함!!!!

```
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>  
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<script type="text/javascript">
	$(document).ready(function(){
		$("#modify").submit(function(event){			// "" 잊지 말 것 !!!
			event.preventDefault();
			console.log("modify click");
			
			var iId = $("#iId").val(); 					// "" 잊지 말 것 !!!
			var iName = $("#iName").val(); 
			var iTitle = $("#iTitle").val(); 
			var iContent = $("#iContent").val();
			
			var form = {
				iId : iId,
				iName : iName,
				iTitle : iTitle,
				iContent : iContent
			}
			
			$.ajax({
				type : "PUT",
				url : $(this).attr("action"),
				cache : false,
				data : JSON.stringify(form),
				contentType : 'application/json; charset=utf-8',
				success : function(result){
					console.log("result : " + result );
					$(location).attr('href', '${pageContext.request.contextPath}/restful/board/')
				},
				error : function(e){
					alert("오류가 발생했습니다.");
					console.log(e);
				}
			}); // ajax end
		}); // event end
	}); // ready end
</script>

</head>
<body>
	<form id="modify" action="${pageContext.request.contextPath }/restful/board/${content_view.iId }" >
	<input type="hidden" id="iId" value="${content_view.iId }">
	<table width="600" cellpadding="0" cellspacing="0" border="1">
		<tr>
			<td>글번호</td>
			<td>${content_view.iId }</td>
		</tr>
		
		<tr>
			<td>조회수</td>
			<td>${content_view.iHit }</td>
		</tr>		
		
		<tr>
			<td>이름</td>
			<td><input type="text" id="iName" value="${content_view.iName }" ></td>
		</tr>
		
		<tr>
			<td>제목</td>
			<td><input type="text" id="iTitle" value="${content_view.iTitle }" ></td>		
		</tr>		
		
		<tr>
			<td>내용</td>
			<td><textarea id="iContent" rows="50" cols="30">${content_view.iContent }</textarea></td>		
		</tr>	
		
		<tr>
			<td colspan="2">
				<input type="submit" value="수정">
				<a href="${pageContext.request.contextPath }/restful/board/">목록 보기</a>
				<a href="${pageContext.request.contextPath }/restful/board/${content_view.iId}">답변</a>
			</td>		
		</tr>	

	</table>
	</form>
</body>
</html>
```

#### **[ views ] - reply_view.jsp**

- form 태그 + ajax 사용할 때는 GET,POST 등의 방법에 상관없이 form 태그 때문에 넘기는 방법을 앞서 사용한 방법처럼 적용해야 함.
  - data : JSON.stringify(form)
    - 이때 form은 자바스크립트의 객체 형식으로 가져갈 내용들을 변수에 담아 넣어줘야 함.
    - 변수에 담을 때 input 태그의 value 값을 가져오는 메소드를 사용해야 하기 때문에 input 태그의 이름은 name이 아닌 id를 사용하도록 하자.
  - contentType : 'application/json; charset=utf-8'

```
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>  
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<script>
	$(document).ready(function() {
		$("#reply").submit(function(event){
			event.preventDefault();
			console.log("reply submit");
			
			var iId = $("#iId").val();
			var iName = $("#iName").val();
			var iTitle = $("#iTitle").val();
			var iContent = $("#iContent").val();
			var iGroup = $("#iGroup").val();
			var iStep = $("#iStep").val();
			var iIndent = $("#iIndent").val();
			
			console.log(iContent);
			
			var form = {
				iId : iId,
				iName : iName,
				iTitle : iTitle,
				iContent : iContent,
				iGroup : iGroup,
				iStep : iStep,
				iIndent : iIndent
			};
			
			$.ajax({
				type : "POST",
				url : $(this).attr("action"),
				cache : false,
				data : JSON.stringify(form),
				contentType : 'application/json; charset=utf-8',
				success : function(result){
					if(result == "SUCCESS"){
						console.log("success");
						$(location).attr('href', '${pageContext.request.contextPath}/restful/board/')
					}
				},
				error : function(e){
					console.log(e);
				}
				
			}); // ajax end
		}); // submit end
	}); // ready end
</script>

</head>
<body>
	<form id="reply" action="${pageContext.request.contextPath }/restful/board/${reply_view.iId }" method="post">
	<input type="hidden" id="iId" value="${reply_view.iId }">	
	<input type="hidden" id="iGroup" value="${reply_view.iGroup }">	
	<input type="hidden" id="iStep" value="${reply_view.iStep }">	
	<input type="hidden" id="iIndent" value="${reply_view.iIndent }">
	<table width="600" cellpadding="0" cellspacing="0" border="1">
		<tr>
			<td>이름</td>
			<td><input type="text" id="iName" value="${reply_view.iName }" ></td>
		</tr>
		
		<tr>
			<td>제목</td>
			<td><input type="text" id="iTitle" value="${reply_view.iTitle }" ></td>		
		</tr>		
		
		<tr>
			<td>내용</td>
			<td><textarea id="iContent" rows="50" cols="30">${reply_view.iContent }</textarea></td>		
		</tr>	
		
		<tr>
			<td colspan="2">
				<input type="submit" value="답변 완료">
				<a href="${pageContext.request.contextPath }/restful/board/">목록 보기</a>
			</td>		
		</tr>	

	</table>
	</form>
</body>
</html>
```



#### 6. 인터셉터 부분

- 구현 순서

  - **DB 생성 → [인터셉터]에서 만든 USERS 테이블 이용하겠음**

  - **사용자 데이터를 담을 빈 생성 (UserVO)**

  - **디스패처 서블릿에서 받은 요청을 가로챌 preHandler, postHandler가 있는 Interceptor클래스 만들기**

    - 반드시 HandlerInterceptorAdapter 객체를 상속(extends)
      - preHandle, postHandle라는 두 개의 메소드를 오버라이딩 함.
      - 역할 : interceptor 객체가 디스패처 서블릿에서 컨트롤러로 넘어가는 중간에서 request, response 객체를 받고 전달해주는 역할.
    - 컨트롤러가 아니므로 @Controller, @AllArgsConstructor 어노테이션은 없어야 함.
    - postHandle가 언제 실행이 되는 것인지가 중요.
      - postHandle는 컨트롤러를 다 지나 다시 디스패처서블릿으로 갈 때 스프링이 호출함.

  - **servlet-context.xml에서 인터셉터 설정하기**

    - 인터셉터의 객체를 생성하고, 어떤 uri로 접근했을 때 인터셉트로 연결할 지 맵핑 지정.

      - 인터셉터의 객체를 생성 : id에 지정한 이름으로 인터셉터 객체를 만들어 넣음. class는 인터셉터의 위치.
      - 어떤 uri로 접근했을 때 인터셉트로 연결할 지 맵핑 
        - path : http:// ..... / 컨택스트명 까지
        - exclude-mapping : resources로 접근하는 것은 가로채면 안된다는 의미

    - 원리 : 브라우저에서 /xxx/list로 접근하면 인터셉터에 걸려서 preHandler가 호출되면서 user 정보를 확인하고, 정보가 있으면 return true가 되어 정상 실행

    - 인터셉터 설정 위치

      - 인터셉터 설정의 위치는 root-context.xml에도 올 수 있지만, 여기 넣은 이유 ? 

        → 컨트롤러 전에 수행되는 것들은 servlet-context.xml에 !!!! 

        → 이후에 수행되는 로직과 관련된 것은 root-context.xml에!!

    - 구현할 때 만난 에러

      - 컨택스트명은 /ex가 맞는데, /board 설정 때문인지 mapping path를 /list로 하면 uri가 없다고 나왔고, /board/list로 바꾸니 실행됨
      - 로그인 아이디는 마음대로 하면 로그인 화면에 아이디로 나오고, 비밀번호는 user임. 이렇게 아이디 입력하고 로그인 하면 일정 시간 동안은 해당 아이디로만 로그인할 수 있음. 
      - 프로젝트 기본 컨트롤러인 HomeController 내용을 지우지 않으면 / 접근에서 에러남.

  - **접근 경로, 메소드를 만들 컨트롤러**

    - Q. / 로 맵핑한 home 메소드가 없으면 /ex/, /ex/board/list, /ex/restful/board 모두 접근이 안됨. home 메소드의 정확한 역할이 뭔가...? servlet-context.xml에서 지정한 맵핑만으로 각 접근에서 로그인 화면이 뜰 거라고 생각했는데 아니었음.

    - home 메소드

    - 로그인 수행 메소드

      - 방법 ① 데이터를 담기 위해 만든 빈 (VO) 사용하는 방법

        - VO를 파라미터로 주면 됨.
        - 함수 등이 있으므로 GET 방식을 사용하면 안됨. POST 방식 사용.

      - **방법 ② UserVO가 아닌 id, pw 각각 받아오는 방법**

        - HttpServletRequest를 파라미터로 주고 getParameter로 각 데이터 받아온 후에, 세션으로 처리해야 함.

          이때는 service, mapper를 통해 DB에서 값을 받아와야 함.

        - 세션

          - 세션은 유저마다 접근하면 할당되는 메모리 영역 = 저장 공간 (32비트 정수). 
          - 이것을 서버에서 가지고 있으면서 세션 번호가 각각 있고, 시간이 부여됨.
          - 이 공간에 로그인 정보를 담았다면, 이것을 클라이언트에 쿠키 형태로 세션 번호와 함께 보내서 다음에 다시 로그인을 시도했을 때 가진 정보로 확인되면 부여된 시간 동안은 로그인이 유지되는 것 (로그인 후에 페이지를 전환하면서 여러 활동을 하기 떄문에 로그인을 한번만 하는 것이 아님. )
          - 이 세션을 사용하기 위해 스프링에서 가져오는 방법은 HttpSession 안에 있는 Session 객체를 가져오는 것.
          - 세션에 있는 user는 전역이기 때문에 jsp에서도 받을 수 있는 것 ??????

      - cf. RedirectAttributes

        - Spring3 에서 제공하는 RedirectAttributes를 사용하면 redirect post 구현이 가능함.
        - 하지만 일회성. 새로고침하면 날라가는 데이터이므로 사용목적에 따라서 사용/불가능 판단을 잘 해야함.
        - 로그인 실패했을 때 브라우저에서 로그인 실패했습니다.. 문구가 새로고침하면 사라짐 = 일회성

  - **로그인 화면 jsp**

    - 부트스트랩 적용

- 구현 코드

**[ com.bit.brd.vo ] - UserVO.java**

```
package com.bit.brd.vo;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class UserVO {
	String username;
	String password;
	char enabled;
}
```

**[ com.bit.brd.interceptor ] - RestfulBoardInterceptor.java**

```
package com.bit.brd.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

import com.bit.brd.vo.UserVO;

import lombok.extern.log4j.Log4j;

@Log4j
public class RestfulBoardInterceptor extends HandlerInterceptorAdapter {
	// preHandle() : 컨트롤러보다 먼저 수행되는 메서드
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		System.out.println("preHandle 실행");
		// session 객체를 가져옴
		HttpSession session = request.getSession();

		// login처리를 담당하는 사용자 정보를 담고 있는 객체를 가져옴
		UserVO user = (UserVO) session.getAttribute("user");

		// 만약 user가 널이면
		if (user == null) {
			log.info("user가 null");
			// 로그인이 안되어 있는 상태이므로 로그인 폼으로 다시 돌려보냄(redirect)
			response.sendRedirect(request.getContextPath());

			return false; // 더이상 컨트롤러 요청으로 가지 않도록 false로 반환함
		}

		// preHandle의 return은 컨트롤러 요청 uri로 가도 되냐 안되냐를 허가하는 의미임
		// 따라서 true로하면 컨트롤러 uri로 가게 됨.
		return true;
	}

	// postHandle가 언제 실행이 되는 것인지가 중요.
	// postHandle는 컨트롤러를 다 지나 다시 디스패처서블릿으로 갈 때 스프링이 호출함.
	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {

		super.postHandle(request, response, handler, modelAndView);
		System.out.println("postHandle 실행");
	}
}
```

**[ servlet-context.xml ]**

```
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
	
	<!-- Enables the Spring MVC @Controller programming model -->
	<annotation-driven />

	<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
	<resources mapping="/resources/**" location="/resources/" />

	<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>
	
	<context:component-scan base-package="com.bit.brd" />
	
   <!-- 인터셉터 객체 생성 -->
   <beans:bean id="boardInterceptor" class="com.bit.brd.interceptor.RestfulBoardInterceptor">
   </beans:bean>   
   
  <!-- Interceptor 설정 / /restful/list 일 때  -->
   <interceptors>
       <interceptor>
           <mapping path="/restful/board"/>          
           <exclude-mapping path="/resources/**"/>
           <beans:ref bean="boardInterceptor"/>
       </interceptor>
   </interceptors> 
	
</beans:beans>
```

**[ com.bit.brd.controller ] - LoginController.java**

```
package com.bit.brd.controller;


import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.bit.brd.service.LoginService;
import com.bit.brd.vo.UserVO;

import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Log4j
@AllArgsConstructor
@Controller
public class LoginController {
	
	private LoginService loginService;
	
	@GetMapping("/")
	public String home() throws Exception {
		log.info("home");
		return "login";	
	}

	// 로그인
	@PostMapping("/login")
	public String login(HttpServletRequest req, RedirectAttributes rttr) throws Exception {
		log.info("post login");
		
		String id = req.getParameter("id");
		String pw = req.getParameter("pw");
		
		// Session 처리를 위한 Session 객체는 HttpSession 안에 있음.
		HttpSession session = req.getSession();
		
		UserVO user = loginService.loginUser(id, pw);
		
		// 유저가 접근할 때, user가 널이면
		if(user == null) {
			session.setAttribute("user", null);
			rttr.addFlashAttribute("msg", false);
		}else {
			session.setAttribute("user", user);
		}
		return "redirect:/";

	}
	
	   // 로그아웃
	   @RequestMapping(value = "/logout")
	   public String logout(HttpSession session) throws Exception {
	      log.info("/member/logout");

	      session.invalidate();

	      return "redirect:/";
	   }
	
}
```

**[ com.bit.brd.service] - LoginService.java  →  방법 ② 를 통해 DB에서 값을 받아오는 방법**

```
package com.bit.brd.service;

import org.springframework.stereotype.Service;

import com.bit.brd.mapper.LoginMapper;
import com.bit.brd.vo.UserVO;

import lombok.AllArgsConstructor;


@Service
@AllArgsConstructor
// 원래 인터페이스가 정석이나, 간단하게 해보기 위해 클래스로 만듦
public class LoginService {

	LoginMapper loginMapper;
	
	public UserVO loginUser(String id, String pw) {
		return loginMapper.logInUser(id, pw);
	}

}
```

**[ com.bit.brd.mapper] - LoginMapper.java   →  방법 ② 를 통해 DB에서 값을 받아오는 방법**

- 인터페이스 - 추상메소드
- @Mapper 어노테이션으로 맵퍼임을 표시해줌.
- xml이 아닌 @Select를 통해 SQL 작성
- 변수가 2개 이상이라면 @Param 대신 @RequestParam 사용.

```
package com.bit.brd.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;

import com.bit.brd.vo.UserVO;


@Mapper
public interface LoginMapper {

	   @Select("select * from users where username = #{username} and password = #{password}")
	   public UserVO logInUser(@Param("username") String username,@Param("password") String password);

}
```

**[ views ] - login.jsp**

```
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<html>
<head>
   <title>로그인</title>
   <!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<!-- Popper JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>


<link rel="canonical" href="https://getbootstrap.com/docs/4.0/examples/sign-in/">

<!-- Bootstrap core CSS -->
<link href="../../dist/css/bootstrap.min.css" rel="stylesheet">

<!-- Custom styles for this template -->
<link href="signin.css" rel="stylesheet">

<style>
	html,
	body {
	  height: 100%;
	}
	
	body {
	  display: -ms-flexbox;
	  display: -webkit-box;
	  display: flex;
	  -ms-flex-align: center;
	  -ms-flex-pack: center;
	  -webkit-box-align: center;
	  align-items: center;
	  -webkit-box-pack: center;
	  justify-content: center;
	  padding-top: 40px;
	  padding-bottom: 40px;
	  background-color: #f5f5f5;
	}
	
	.form-signin {
	  width: 100%;
	  max-width: 330px;
	  padding: 15px;
	  margin: 0 auto;
	}
	.form-signin .checkbox {
	  font-weight: 400;
	}
	.form-signin .form-control {
	  position: relative;
	  box-sizing: border-box;
	  height: auto;
	  padding: 10px;
	  font-size: 16px;
	}
	.form-signin .form-control:focus {
	  z-index: 2;
	}
	.form-signin input[type="text"] {
	  margin-bottom: -1px;
	  border-bottom-right-radius: 0;
	  border-bottom-left-radius: 0;
	}
	.form-signin input[type="password"] {
	  margin-bottom: 10px;
	  border-top-left-radius: 0;
	  border-top-right-radius: 0;
	}
</style>
</head>

<body class="text-center">

  <c:if test="${user == null}">	
    <form class="form-signin" role="form" method="post" autocomplete="off" action="${pageContext.request.contextPath }/login">
      <img class="mb-4" src="https://getbootstrap.com/docs/4.0/assets/brand/bootstrap-solid.svg" alt="" width="72" height="72">
      <h1 class="h3 mb-3 font-weight-normal">Please sign in</h1>
 
      <label for="userId" class="sr-only">아이디</label>
      <input type="text" id="userId" name="id" class="form-control" placeholder="아이디" required autofocus>
      
      <label for="userPass" class="sr-only">패스워드</label>
      <input type="password" id="userPass" name="pw" class="form-control" placeholder="비밀번호" required>
      
      <div class="checkbox mb-3">
        <label>
          <input type="checkbox" value="remember-me"> Remember me
        </label>
      </div>

      <button class="btn btn-lg btn-primary btn-block" type="submit">Sign in</button>
      <p class="mt-5 mb-3 text-muted">&copy; 2017-2018</p>
    </form>
  </c:if>
  
	<c:if test="${msg == false}">
	   <p style="color:#f00;">로그인에 실패했습니다. 아이디 또는 패스워드를 다시 입력해주십시오.</p>
	</c:if>
	
	<c:if test="${user != null}">					<!-- user가 널이 아닐 때 -->
	   <p>${user.username}님 환영합니다.</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	   
	   <a href="${pageContext.request.contextPath }/restful/board">게시판 리스트</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	   <a href="${pageContext.request.contextPath }/logout">로그아웃</a>
	</c:if>  
	
</body>
</html>
```



#### 7. 트랜젝션 부분

- 기본 설정

  - root-context.xml에 트랜젝션 사용을 위한 커넥션풀 객체 넣기

    ```
    	// 1. 트랜잭션을 사용하기 위한 커넥션풀 객체 넣기
    	// DataSourceTransactionManager : 트랜잭션 객체
    	// id="transactionManager" : 이것도 바뀌면 안됨
    	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dataSource" />
        </bean>
        
        // 2. @Transactional을 사용하기 위한 부분
        <tx:annotation-driven transaction-manager="transactionManager" />
    ```

- 트랜잭션 대상

  - Insert, Update, Delete
  - select는 처리 대상이 아님.
  - 이것을 수행할 대상이 하나면 상관없지만,  게시판의 댓글처럼 2개 이상이면 트랜잭션해야 함.

- 방법

  - **Spring Transaction Annotation 사용**

- 따라서 게시판에서 적용하려면?

  - BoardServiceImpl.java에서 reply 메소드에 @Transactional 처리

- 주의 사항

  - **절대 controller에 @Transactional 처리해서는 x**
    - 이유
      - controller에서 @Transactional이 잘 먹지 않음.
      - **controller의 역할은 view로 연결을 해주는 것. 나머지 로직은 반드시 service에 들어가야 함. 따라서 로직이 수행되는 곳에서 @Transactional 처리를 해줘야 역할을 제대로 할 수 있음.**

- 구현 코드

**[ com.bit.brd.service ] - RestfulBoardServiceImpl.java**

```
	@Transactional
	@Override
	public RestfulBoardVO contentView(int getiId) {
		boardMapper.addHit(getiId);
		return boardMapper.contentView(getiId);
	}
	
	
	@Transactional
	@Override
	public void reply(RestfulBoardVO boardVO) {
		boardMapper.replyShape(boardVO);
		boardMapper.reply(boardVO);
	}
```









### 2.부트스트랩으로 로그인 화면구현후 interceptor 적용하여 로그인한 유저에게만 게시판이 보이도록 하시오. 

### >> 프로젝트[spring_board_5_test]

**[ src ... views ] - login.jsp**

```
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<html>
<head>
   <title>로그인</title>
   <!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<!-- Popper JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>


<link rel="canonical" href="https://getbootstrap.com/docs/4.0/examples/sign-in/">

<!-- Bootstrap core CSS -->
<link href="../../dist/css/bootstrap.min.css" rel="stylesheet">

<!-- Custom styles for this template -->
<link href="signin.css" rel="stylesheet">

<style>
	html,
	body {
	  height: 100%;
	}
	
	body {
	  display: -ms-flexbox;
	  display: -webkit-box;
	  display: flex;
	  -ms-flex-align: center;
	  -ms-flex-pack: center;
	  -webkit-box-align: center;
	  align-items: center;
	  -webkit-box-pack: center;
	  justify-content: center;
	  padding-top: 40px;
	  padding-bottom: 40px;
	  background-color: #f5f5f5;
	}
	
	.form-signin {
	  width: 100%;
	  max-width: 330px;
	  padding: 15px;
	  margin: 0 auto;
	}
	.form-signin .checkbox {
	  font-weight: 400;
	}
	.form-signin .form-control {
	  position: relative;
	  box-sizing: border-box;
	  height: auto;
	  padding: 10px;
	  font-size: 16px;
	}
	.form-signin .form-control:focus {
	  z-index: 2;
	}
	.form-signin input[type="text"] {
	  margin-bottom: -1px;
	  border-bottom-right-radius: 0;
	  border-bottom-left-radius: 0;
	}
	.form-signin input[type="password"] {
	  margin-bottom: 10px;
	  border-top-left-radius: 0;
	  border-top-right-radius: 0;
	}
</style>
</head>

<body class="text-center">

  <c:if test="${user == null}">	
    <form class="form-signin" role="form" method="post" autocomplete="off" action="${pageContext.request.contextPath }/login">
      <img class="mb-4" src="https://getbootstrap.com/docs/4.0/assets/brand/bootstrap-solid.svg" alt="" width="72" height="72">
      <h1 class="h3 mb-3 font-weight-normal">Please sign in</h1>
 
      <label for="userId" class="sr-only">아이디</label>
      <input type="text" id="userId" name="id" class="form-control" placeholder="아이디" required autofocus>
      
      <label for="userPass" class="sr-only">패스워드</label>
      <input type="password" id="userPass" name="pw" class="form-control" placeholder="비밀번호" required>
      
      <div class="checkbox mb-3">
        <label>
          <input type="checkbox" value="remember-me"> Remember me
        </label>
      </div>

      <button class="btn btn-lg btn-primary btn-block" type="submit">Sign in</button>
      <p class="mt-5 mb-3 text-muted">&copy; 2017-2018</p>
    </form>
  </c:if>
  
	<c:if test="${msg == false}">
	   <p style="color:#f00;">로그인에 실패했습니다. 아이디 또는 패스워드를 다시 입력해주십시오.</p>
	</c:if>
	
	<c:if test="${user != null}">					<!-- user가 널이 아닐 때 -->
	   <p>${user.username}님 환영합니다.</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	   
	   <a href="${pageContext.request.contextPath }/restful/board">게시판 리스트</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	   <a href="${pageContext.request.contextPath }/logout">로그아웃</a>
	</c:if>  
	
</body>
</html>
```

**[ 결과 ]**

![210210_as1](C:\Users\김슬기\Desktop\java 캡쳐\210210_as1.PNG)

![210210_as2](C:\Users\김슬기\Desktop\java 캡쳐\210210_as2.PNG)

![210210_as3](C:\Users\김슬기\Desktop\java 캡쳐\210210_as3.PNG)

![210210_as4](C:\Users\김슬기\Desktop\java 캡쳐\210210_as4.PNG)









### 3.intercptor의 개념에 대하여 설명하시오.

- 그동안 게시판을 만들면서 무조건 접근 경로를 입력하면 누구나 접근할 수 있도록 했음. 이때 허락된 유저만 접근할 수 있도록 접근 시 로그인 화면을 먼저 띄우고, 로그인이 완료되면 게시판을 볼 수 있도록 하는 것이 인터셉터 기능.

- 전자정부 프레임에서의 대표적인 접근 방법

  ![시큐리티테이블1](C:\Users\김슬기\Desktop\java 캡쳐\시큐리티테이블1.png)

- 작동 방식

  ![필터-에이오피-인터필터](C:\Users\김슬기\Desktop\java 캡쳐\필터-에이오피-인터필터.png)

  - 들어온 요청이 디스패처 서블릿을 거쳐 컨트롤러로 가기 전에 preHandler를 통해 인터셉터가 요청을 가로채 사용자가 맞는지 확인함. 확인이 되면 컨트롤러로 연결해주고, postHandler를 통해 응답함.







### 4.부트스트랩이란?

- 의미 : 트위터 사에서 만든 웹사이트를 쉽게 만들 수 있게 도와주는 HTML, CSS, JS 프레임 워크.

- 특징

  - 부트스트랩을 적용할 때는 부트스트랩에서 지정한 class="" 를 속성으로 주면 됨.
  - 이 말은 부트스트랩을 사용하려면 일종의 문법들을 알아야 한다는 것. 다 외울 수는 없으니 W3school을 참고하자.

- 기본 설정

  - 부트스트랩을 사용하기 위해서는 다운로드 받거나 CDN을 입력해줘야 함.

  - CDN

    ```
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    
    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    
    <!-- Popper JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    
    <!-- Latest compiled JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    ```

- 그리드 시스템

  - 부트스트랩은 기본적으로 화면을 세로로 12개로 나눠 필요한 만큼 할당해 사용함.

    ![bootstrap1](C:\Users\김슬기\Desktop\java 캡쳐\bootstrap1.PNG)

  - 그리드 시스템은 화면 크기의 변화에 따라 반응하는 부트스트랩의 특징인 "반응형"을 만드는데 중요한 역할을 함.

  - 칼럼의 클래스 종류

    -  .col-xs-* : 화면 크기의 변화와 상관없이 이 클래스가 적용된 요소는 항상 가로로 배치됨.
    -  .col-sm-* : 화면 크기의 변화에 따라 화면이 768px 이하가 되면 이 클래스가 적용된 요소는 가로에서 세로로 정렬되기 시작함.
    -  .col-md-* : 화면 크기의 변화에 따라 화면이 992px이하가 되면 이 클래스가 적용된 요소는 가로에서 세로로 정렬되기 시작함.
    -  .col-lg-* : 화면 크기의 변화에 따라 화면이 1200px이하가 되면 이 클래스가 적용된 요소는 가로에서 세로로 정렬되기 시작함.

